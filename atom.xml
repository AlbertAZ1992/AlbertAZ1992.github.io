<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Deacyn]]></title>
  <subtitle><![CDATA[China, Shanghai]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://deacyn.com/"/>
  <updated>2015-06-01T03:38:40.819Z</updated>
  <id>http://deacyn.com/</id>
  
  <author>
    <name><![CDATA[Deacyn Zhang]]></name>
    <email><![CDATA[1379489640@qq.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[JavaScript面向对象笔记]]></title>
    <link href="http://deacyn.com/2015/03/31/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0/"/>
    <id>http://deacyn.com/2015/03/31/JavaScript面向对象笔记/</id>
    <published>2015-03-31T13:52:04.000Z</published>
    <updated>2015-03-31T15:57:43.000Z</updated>
    <content type="html"><![CDATA[<p>最近一直在刷犀牛书，感觉脑子里的知识还是太乱太零散，需要总结梳理一下。现在首先从面向对象编程开始。<br><a id="more"></a></p>
<h2 id="有关继承"><strong>有关继承</strong></h2>
<p>JavaScript中的所有数据类型都可以归结为对象，因此为了将所有对象联系起来，就需要继承机制。<br>首先JavaScript通过<code>new</code>，从原型对象生成实例对象。但是，JavaScript（一下简称JS）又没有引入<strong>“类”</strong>，因此JS的<code>new</code>调用的不是类，而是<strong>“构造函数”</strong>。</p>
<p>比如像这样,构建一个猫对象的原型：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Cat</span><span class="params">(name)</span></span>{
    <span class="keyword">this</span>.name=name;
}
</code></pre><p>对此构造函数使用<code>new</code>生成实例：</p>
<pre><code><span class="keyword">var</span> catA=<span class="keyword">new</span> Cat(<span class="string">'小黑'</span>);
alert(catA.name);<span class="comment">//小黑</span>
</code></pre><p>然而，通过<code>this</code>创建的属性会被实例对象独立继承拷贝，相对独立，并非共有，也会浪费内存。因此JS还提供了<strong>prototype</strong>模式，用来创建共有属性。每个构造函数都有一个<code>prototype</code>属性，指向一个对象该对象的所有属性和方法，都会被构造函数的实例继承。</p>
<p>这样一来，实例对象一旦创建，会自动引用<code>prototype</code>对象的属性和方法。共享属性和方法放在<code>prototype</code>对象中，是引用的；不共享的属性和方法放在构造函数内部，是本地的：</p>
<pre><code>Cat.prototype.<span class="built_in">type</span>=<span class="string">'猫科'</span>;
Cat.prototype.eat=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{alert(<span class="string">"吃鱼"</span>);};
</code></pre><p>生成实例则是这样：</p>
<pre><code>alert(catA.<span class="keyword">type</span>);<span class="comment">//猫科</span>
catA.eat();<span class="comment">//吃鱼</span>
</code></pre><p>如果再实例话一个对象，起共有属性和方法均指向<code>prototype</code>对象，因此提高了运行效率：</p>
<pre><code><span class="keyword">var</span> catB=<span class="keyword">new</span> Cat(<span class="string">'小白'</span>);
alert(catA.eat==catB.eat);<span class="comment">//True</span>
</code></pre><p>还有一些验证继承模式的方法：</p>
<p>1.实例会自动含有一个<code>constructor</code>属性，指向它的构造函数：</p>
<pre><code>alert(catA.<span class="keyword">constructor</span>==Cat);<span class="comment">//True</span>
</code></pre><p>2.通过<code>instanceof</code>运算符可以验证<strong>原型对象</strong>和<strong>实例对象</strong>的关系：</p>
<pre><code>alert(catA <span class="keyword">instanceof</span> Cat);<span class="comment">//True</span>
</code></pre><p>3.通过<code>isPrototypeOf()</code>判断<strong>原型对象</strong>和<strong>实例对象</strong>的关系：</p>
<pre><code><span class="function">alert</span>(Cat<span class="class">.prototype</span><span class="class">.isPrototypeOf</span>(catA));<span class="comment">//True</span>
</code></pre><p>4.通过<code>hasOwnProperty()</code>判断某一<strong>属性</strong>是来自本地还是继承引用：</p>
<pre><code>alert(catA.hasOwnProperty(<span class="string">"name"</span>));<span class="comment">//True</span>
alert(catA.hasOwnProperty(<span class="string">"type"</span>));<span class="comment">//False</span>
</code></pre><p>5.通过<code>in</code>运算符判断某个<strong>实例</strong>是否含有某个<strong>属性</strong>（无论本地还是引用）：</p>
<pre><code>alert(<span class="string">"name"</span> <span class="keyword">in</span> catA);<span class="comment">//True</span>
alert(<span class="string">"type"</span> <span class="keyword">in</span> catA);<span class="comment">//True</span>
</code></pre><h2 id="有关构造函数的继承"><strong>有关构造函数的继承</strong></h2>
<p><strong>构造函数</strong>的继承，其实就是生成一个<strong>继承了多个对象</strong>的<strong>实例</strong></p>
<p>像下面这样，有两个构造函数，需要实现<code>Cat</code>继承<code>Animal</code>：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Cat</span><span class="params">(name,color)</span></span>{
    <span class="keyword">this</span>.name=name;
    <span class="keyword">this</span>.color=color;
}
<span class="function"><span class="keyword">function</span> <span class="title">Animal</span><span class="params">()</span></span>{
    <span class="keyword">this</span>.type=<span class="string">"动物"</span>;
}
</code></pre><p>有以下方法：</p>
<p>1.构造函数绑定。使用<code>call</code>和<code>apply</code>把父对象构造函数绑定在自对象上：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Cat</span><span class="params">(name,color)</span></span>{
    Animal.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);
    <span class="keyword">this</span>.name=name;
    <span class="keyword">this</span>.color=color;
}
<span class="keyword">var</span> catA=<span class="keyword">new</span> Cat(<span class="string">"小黑"</span>,<span class="string">"黑色"</span>);
alert(catA.type);<span class="comment">//动物</span>
</code></pre><p>2.prototype模式。把子对象的<code>prototype</code>属性指向<strong>父对象的实例</strong>：</p>
<pre><code><span class="attribute">Cat.prototype </span>=<span class="string"> new Animal();</span>
</code></pre><p>这样<code>prototype</code>对象原来的值被完全删除，包括指向其构造函数的<code>constructor</code>属性，并赋予了一个新的值。</p>
<p>因此需要重新规定其构造函数的指向：</p>
<pre><code><span class="constant">Cat.prototype.constructor</span>=Cat;<span class="comment">//</span>
</code></pre><p>这样之后：</p>
<pre><code><span class="keyword">var</span> catA=<span class="keyword">new</span> Cat(<span class="string">"小黑"</span>,<span class="string">"黑色"</span>);
alert(catA.<span class="keyword">type</span>);<span class="comment">//动物</span>
</code></pre><p>3.直接继承父对象的<code>prototype</code>。可以让Cat跳过 Animal，直接继承Animal.prototype。<br>先设置父对象的<code>prototype</code>：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Animal</span><span class="params">()</span></span>{ }
Animal.prototype.<span class="built_in">type</span> = <span class="string">"动物"</span>;
</code></pre><p>再把Cat的<code>prototype</code>指向Animal的<code>prototype</code>，当然因为修改了<code>prototype</code>,构造函数也要改：</p>
<pre><code>Cat.<span class="keyword">prototype</span> = Animal.<span class="keyword">prototype</span>;
Cat.<span class="keyword">prototype</span>.constructor = Cat;
</code></pre><p>这样做的结果是不错，但是因为把父对象和子对象的原型关联了，任何对<code>Cat.prototype</code>的修改都会反映到<code>Animal.prototype</code>，其实<code>Animal.prototype</code>对象的<code>constructor</code>属性也已经被修改成<code>Cat</code>了。</p>
<p>因此最好的方法是利用空对象作为中介：</p>
<pre><code><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span><span class="params">()</span><span class="comment">{}</span>;</span>
F.prototype = Animal.prototype;
Cat.prototype = <span class="keyword">new</span> F();
Cat.prototype.<span class="keyword">constructor</span> = Cat;
</code></pre><p>现将<strong>空对象</strong>的<code>prototype</code>指向<strong>父对象</strong>的<code>prototype</code>，再把<strong>子对象</strong>的<code>prototype</code>属性指向<strong>空对象的实例</strong>，这其实是上面两种方法的结合。</p>
<p>4.prototype模式的封装函数，这是更有可用性的方法：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">extend</span><span class="params">(Child, Parent)</span> </span>{
    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{};
    F.prototype = <span class="keyword">Parent</span>.prototype;
    Child.prototype = <span class="keyword">new</span> F();
    Child.prototype.constructor = Child;
}
</code></pre><p>调用的时候像这样：</p>
<pre><code>extend(Cat,Animal);
<span class="keyword">var</span> catA = <span class="keyword">new</span> Cat(<span class="string">"小黑"</span>,<span class="string">"黑色"</span>);
alert(catA.<span class="keyword">type</span>); <span class="comment">// 动物</span>
</code></pre><p>5.纯粹拷贝方法，把父对象的所有属性和方法拷贝进子对象：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">extend</span><span class="params">(Child, Parent)</span> </span>{
    <span class="keyword">var</span> p = Parent.prototype;
    <span class="keyword">var</span> c = Child.prototype;
    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) {
        c[i] = p[i];
    }
    c.uber = p;<span class="comment">//这是为了方便子对象直接调用父对象的prototype属性</span>
}
</code></pre><h2 id="有关非构造函数的继承"><strong>有关非构造函数的继承</strong></h2>
<p>所谓非构造函数，就是普通对象,像下面这样，有两个普通对象，需要实现<code>Cat</code>继承<code>Animal</code>：</p>
<pre><code><span class="keyword">var</span> Cat={
    name:<span class="string">"猫"</span>    
}
<span class="keyword">var</span> Animal={
    <span class="keyword">type</span>:<span class="string">"动物"</span>
}
</code></pre><p>有以下方法：</p>
<p>1.使用object()函数。object()函数就是把<strong>子对象</strong>的<code>prototype</code>属性指向<strong>父对象</strong>，使子对象与父对象连在一起:</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">object</span><span class="params">(o)</span> </span>{
    <span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span> </span>{}
    F.prototype = o;
    <span class="keyword">return</span> <span class="keyword">new</span> F();
}
</code></pre><p>因此先在父对象的基础上生成子对象：</p>
<pre><code><span class="keyword">var</span> Cat = <span class="keyword">object</span>(Animal);
</code></pre><p>子对象随后继承了父对象的属性：</p>
<pre><code>alert(Cat.<span class="keyword">type</span>); <span class="comment">//动物</span>
</code></pre><p>2.浅拷贝。把父对象的属性全部拷贝给子对象，实现继承：</p>
<pre><code>function extendCopy(p) {
    <span class="keyword">var</span> <span class="built_in">c</span> = {};
    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) {
        <span class="built_in">c</span>[i] = p[i];
    }
    <span class="built_in">c</span>.uber = p;
    <span class="keyword">return</span> <span class="built_in">c</span>;
}
</code></pre><p>调用的时候像这样：</p>
<pre><code><span class="keyword">var</span> Cat = extendCopy(Animal);
alert(Cat.<span class="keyword">type</span>); <span class="comment">// 动物</span>
</code></pre><p><strong>浅拷贝存在一个问题：</strong><br>如果父对象的属性等于数组或另一个对象，那么子对象获得的只是一个内存地址引用，而不是真正拷贝，因此存在父对象可能被篡改。</p>
<p>3.深拷贝。用来完成包括数组和对象的拷贝。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span><span class="params">(p,c)</span></span>{
    <span class="keyword">var</span> c||{};
    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> p){
        <span class="keyword">if</span>(<span class="keyword">typeof</span> p[i]===<span class="string">'object'</span>){<span class="comment">//判断父对象的属性是否为对象</span>
            c[i]=(p[i].contructor===<span class="built_in">Array</span>)?[]:{};<span class="comment">//或者数组</span>
            deepCopy(p[i],c[i]);<span class="comment">//递归调用，拷贝数组对象内部属性</span>
        }
        <span class="keyword">else</span>{
            c[i]=p[i];
        }
    }
    <span class="keyword">return</span> c;
}
</code></pre><p>调用的时候依然这样：</p>
<pre><code><span class="keyword">var</span> Cat = deepCopy(Animal);
alert(Cat.<span class="keyword">type</span>); <span class="comment">// 动物</span>
</code></pre><p>先到这里～～</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近一直在刷犀牛书，感觉脑子里的知识还是太乱太零散，需要总结梳理一下。现在首先从面向对象编程开始。<br>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://deacyn.com/tags/javascript/"/>
    
      <category term="note" scheme="http://deacyn.com/tags/note/"/>
    
      <category term="前端笔记" scheme="http://deacyn.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[有关Git]]></title>
    <link href="http://deacyn.com/2015/03/01/%E6%9C%89%E5%85%B3git/"/>
    <id>http://deacyn.com/2015/03/01/有关git/</id>
    <published>2015-03-01T10:45:38.000Z</published>
    <updated>2015-03-01T13:14:12.000Z</updated>
    <content type="html"><![CDATA[<p>自己写的东西一般在本地，如果换电脑需要更新源文件时候就会比较麻烦。<br>这时候可以比较靠谱的方法就是用Git来管理。有关Git的知识很多，一篇文章不可能全部覆盖，这方面最简单也是最实用的例子就是在Github上的文件控制。<br><a id="more"></a></p>
<p>下面主要记录最常用的一些命令：</p>
<h2 id="Step_by_Step"><strong>Step by Step</strong></h2>
<p>1.首先需要在github上创建一个新的<code>repository</code> ，也就是文件仓库。文件仓库的名字跟本地文件夹同名，这里把它命名为<code>myFirstRepo</code></p>
<p>2.需要<code>cd</code>进入本地<code>myFirstRepo</code>文件夹，用<code>git init</code>初始化文件仓库</p>
<p>3.添加远程仓库的地址</p>
<pre><code>git remote <span class="built_in">add</span> origin http<span class="variable">s:</span>//github.<span class="keyword">com</span>/Deacyn/myFirstRepo.git
</code></pre><p>并更新，上传本地当前分支代码到github项目默认的master分支上</p>
<pre><code>git <span class="keyword">push</span> -u origin master
</code></pre><p>第一次<code>push</code>的时候添加了<code>-u</code>参数，表示设置一条新的upstream。后续的上传更新只需要：</p>
<pre><code>git <span class="keyword">push</span> origin master
</code></pre><p>注意这里上传的都是当<strong>前分</strong>支代码，如果要上传本地所有分支代码，则直接<code>git push</code>就好了。</p>
<h2 id="注意点"><strong>注意点</strong></h2>
<p>1.在其他平台，只需要使用<code>git clone &lt;address&gt;</code>，就可以将源文件复制到本地.</p>
<p>2.很多时候并不是所有文件都要上传，因此可以在项目文件夹中添加.gitignore文件，在其中设置忽略的目录，比如<code>node_modules/</code>、<code>public/</code>和<code>.deploy/</code>。这样<code>push</code>的时候不会关注上述目录。</p>
<p>3.随后进入到项目文件夹使用<code>git add .</code>将当前<strong>所有</strong>文件提交到缓存区。</p>
<p>4.接着<code>git commit -m &quot;version&quot;</code> 将文件提交到本地仓库</p>
<p>5.最后是<code>git push origin master</code>,将本地仓库的改动推送到在线仓库</p>
<p>6.当远程仓库有更新时，使用<code>git pull</code>进行同步</p>
<pre><code><span class="input"><span class="prompt">git pull &lt;远程主机名&gt;</span> &lt;远程分支名&gt;<span class="symbol">:&lt;</span>本地分支名&gt;</span>
</code></pre><p>比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样：</p>
<pre><code>git pull origin nex<span class="variable">t:master</span>
</code></pre><p>如果远程分支是与<strong><em>当前分支</em></strong>合并，则冒号后面的部分可以省略，像这样：</p>
<pre><code>git pull origin <span class="keyword">next</span>
</code></pre><p>这等同于先做git fetch，再做git merge，像下面这样：</p>
<pre><code>git fetch origin
git <span class="operator"><span class="keyword">merge</span> origin/<span class="keyword">next</span></span>
</code></pre><p>到这差不多了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>自己写的东西一般在本地，如果换电脑需要更新源文件时候就会比较麻烦。<br>这时候可以比较靠谱的方法就是用Git来管理。有关Git的知识很多，一篇文章不可能全部覆盖，这方面最简单也是最实用的例子就是在Github上的文件控制。<br>]]>
    
    </summary>
    
      <category term="git" scheme="http://deacyn.com/tags/git/"/>
    
      <category term="note" scheme="http://deacyn.com/tags/note/"/>
    
      <category term="项目笔记" scheme="http://deacyn.com/categories/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sketch]]></title>
    <link href="http://deacyn.com/2015/02/14/Sketch/"/>
    <id>http://deacyn.com/2015/02/14/Sketch/</id>
    <published>2015-02-14T04:28:14.000Z</published>
    <updated>2015-02-14T05:06:04.000Z</updated>
    <content type="html"><![CDATA[]]></content>
    <summary type="html">
    <![CDATA[]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript 初步总结]]></title>
    <link href="http://deacyn.com/2015/02/12/Javascript/"/>
    <id>http://deacyn.com/2015/02/12/Javascript/</id>
    <published>2015-02-12T12:13:29.000Z</published>
    <updated>2015-02-12T16:57:30.000Z</updated>
    <content type="html"><![CDATA[<p>javascript初学完一轮，这里需要把能想起来的东西整理一遍。当然javascript涉及的内容巨量，我只能以初学者的视角，描述出知识点的轮廓，但重要的细节也会尽力说明。<br><a id="more"></a></p>
<h2 id="有关javascript"><strong>有关javascript</strong></h2>
<p>首先它是一门程序语言，解释型语言，javascript名称里虽然包含了java，但实际上它根java是两回事。</p>
<p>起初大家对javascript的认识主要是用于网页行为表现层，实现各种交互效果。过去，javascript被认为是由浏览器解释运行的客户端脚本语言，因此难以写服务器上的文件、难以从其他服务器的网页上读取信息等等。</p>
<p>但是现在很多出色的应用、酷炫的效果都源自javascript，开发平台也不再局限于浏览器（毕竟web领域发展太快）。现在的web 开发，在确保用户安全的前提下，javascript几乎可以做到你能想到的任何事情。</p>
<p>比如<a href="http://javascript.ruanyifeng.com/nodejs/commonjs.html" target="_blank" rel="external">CommonJS规范</a>就是服务器端模块的规范，开发者可以使用CommonJS API编写应用程序，然后这些应用可以运行在不同的JavaScript解释器和不同的主机环境中。</p>
<h2 id="使用javascript"><strong>使用javascript</strong></h2>
<p>使用javascript需要添加 <code>&lt;script&gt;</code>标签，在html中直接添加，需要像这样：</p>
<pre><code><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
alert(<span class="string">"what?"</span>);
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p>更常用的方法是写在单独的.js文件中再通过<code>&lt;script&gt;</code>标签引用，像这样：</p>
<pre><code><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"demo.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p>在html5 中，通常type属性也可以不写。 </p>
<p>因为<code>&lt;script&gt;</code>中代码加载后就会立即执行，因此它放置的位置会影响整体页面的性能，按惯例会放在页面底部，<code>&lt;/body&gt;</code>标签之前（当然这里先不考虑async和defer异步加载的问题）。</p>
<h2 id="javascript语法重点"><strong>javascript语法重点</strong></h2>
<p> 首先javascript区分大小写，比如<code>woca</code>和<code>Woca</code>是不同的变量</p>
<p> <strong>变量</strong></p>
<p>说到变量，javascript中变量是一种 <em>松散类型</em> 的变量，用关键字<code>var</code>声明即可，你不用去关心变量类型是否匹配。此外如果声明变量不使用<code>var</code>，变量会被当作额外的全局变量，这种还是要尽量省略。</p>
<p>javascript中一共5种基本数据类型：数值、字符串、布尔值、undefined 和 null，声明和定义起来像这样：</p>
<pre><code><span class="keyword">var</span> typeA = <span class="number">2.1</span>, <span class="comment">//Number，数值</span>
    typeB = <span class="string">"arsenal"</span>, <span class="comment">//String 字符串</span>
    typeC = <span class="literal">false</span>, <span class="comment">//Boolean 布尔值</span>
    typeD = <span class="literal">undefined</span>, <span class="comment">//Undefined，当然也可以不定义</span>
    typeE = <span class="literal">null</span>, <span class="comment">//Null 空</span>
</code></pre><p>变量未做初始化时默认值为undefined。此外还有一类引用数据类型，虽各有不同，但均属于Object：    </p>
<pre><code><span class="keyword">var</span> typeF = <span class="keyword">new</span> <span class="built_in">Object</span>(), <span class="comment">//Object 对象</span>
    typeG = [<span class="string">"1"</span>, <span class="string">"2"</span>], <span class="comment">//Array 数组</span>
    typeH = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2015</span>, <span class="number">2</span>, <span class="number">12</span>), <span class="comment">//Date 日期,new Date()则取当前时间</span>
    typeI = <span class="regexp">/^\stext\s$/</span>, <span class="comment">//RegExp 正则表达式</span>
    typeJ = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{}; <span class="comment">//Function 函数</span>
</code></pre><p> <strong>对象</strong></p>
<p>javascript是以对象Object为基础的语言。上面也提到，除了基本数据类型，其他所有引用数据类型本质上属于Object。</p>
<p>Object的本质是  <em>一组数据和功能的集合</em></p>
<p>因此函数其实是特殊的Object，通过关键字function声明,包含数据和功能。只不过它同时可以存储任意数量的语句，可以传参数，可以调用执行。</p>
<p>在访问对象属性、调用方法时，需要用到 .点语法。像这样：</p>
<pre><code><span class="keyword">var</span> myObject = {}; <span class="comment">//当然也可以var myObject = new Object()         </span>
    myObject.name = <span class="string">"deacyn"</span>;  <span class="comment">//定义属性</span>
    myObject.talk = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{  <span class="comment">//定义方法，函数</span>
        alert(<span class="string">"Hello!"</span> + <span class="keyword">this</span>.name);
    };
    myObject.talk(); <span class="comment">// 调用对象方法</span>
</code></pre><p>当然也可以用一种 <em>对象字面量表示法</em> 来写，这也是惯用方法, 从花括号{开始，到花括号加分号};结束，通过 <strong>属性名：属性值</strong> 的形式依次定义不同的属性。不同的属性之间以逗号,分隔,像下面这样:</p>
<pre><code><span class="keyword">var</span> myObject={
    name: <span class="string">"deacyn"</span>,
    talk: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        alert(<span class="string">"Hello!"</span> + <span class="keyword">this</span>.name);
    }
};
</code></pre><h2 id="实现功能"><strong>实现功能</strong></h2>
<p>说一下如何用javascript实现想要的功能。<br>通常需要实现的功能都是事件驱动的，称为Event Driven，也就是当某些事件发生后会出现功能。<br>以一个点击事件为例，点击后会消失：</p>
<p>那么实现该事件驱动功能主要流程分三部分，如下：</p>
<pre><code>1.选取相关元素，获得其引用
2.为元素绑定事件
3.定义事件处理函数
</code></pre><p>这样就可以写出像下面这样的代码：</p>
<pre><code><span class="comment">//获取元素</span>
<span class="keyword">var</span> demo = <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>);

<span class="comment">//为元素绑定事件，并定义处理函数</span>
demo.onclick = <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>{
    <span class="keyword">this</span>.style.display = <span class="string">"none"</span>;
};
</code></pre><p>当然这只是一个很简单的功能，实现起来不复杂。但是遇到相对复杂的工作，特别是涉及到浏览器兼容性问题时，用原生javascript处理起来就很是麻烦，就需要jQuery这类javascript库，利用简化方便的高层次接口。</p>
<h2 id="浏览器对象模型（BOM）"><strong>浏览器对象模型（BOM）</strong></h2>
<p>BOM,就是Browser Object Model，它提供了很多Object用于访问浏览器的功能。BOM尚无正式标准。由于现代浏览器已经几乎实现了 JavaScript 交互性方面的相同方法和属性，因此常被认为是 BOM 的方法和属性。</p>
<p>其中顶层对象是window，所有浏览器都支持 window 对象。它表示浏览器窗口。<br>所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。</p>
<p>全局变量是 window 对象的属性；全局函数是 window 对象的方法；都是定义在window对象上。</p>
<h2 id="文档对象模型（DOM）"><strong>文档对象模型（DOM）</strong></h2>
<p>DOM，就是Document Object Model。</p>
<p>DOM已经是W3C的一个推荐标准，为基本的文档结构和查询提供接口，本质上是独立于javascript的，不过在javascript中可以，也经常需要使用。</p>
<p>DOM实际上是以树形结构表示HTML和XML文档，定义了遍历这个树和检查、修改树的节点的方法和属性。比如下面这段：</p>
<pre><code><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"wrapper"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">h2</span> <span class="attribute">class</span>=<span class="value">"title"</span>&gt;</span>Title<span class="tag">&lt;/<span class="title">h2</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span> <span class="attribute">class</span>=<span class="value">"content"</span>&gt;</span>Content<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</code></pre><p>对应的树形结构是</p>
<pre><code>element div.wrapper
    <span class="string">|</span>
    <span class="string">|__element h2.title__text Title</span>
    <span class="string">|</span>
    <span class="string">|__element p.content__text Content</span>
</code></pre><h2 id="Ajax"><strong>Ajax</strong></h2>
<p>Ajax, Asynchronous JavaScript and XML的缩写。</p>
<p>Ajax的技术核心是XMLHttpRequest对象，它使得javascript可以在<strong><em>任何时候和服务器进行通讯而不必刷新整个页面</em></strong>。一个简单的Ajax体验就是你在搜索引擎print的时候，会有自动匹配提示。</p>
<p>比如服务器端的一个demo.php文件：</p>
<pre><code><span class="php"><span class="preprocessor">&lt;?php</span>
    <span class="keyword">echo</span> <span class="string">"text from server."</span>;
<span class="preprocessor">?&gt;</span></span>
</code></pre><p>利用Ajax的javascript代码：</p>
<pre><code><span class="keyword">var</span> myRequest = new <span class="type">Request</span>({
    <span class="keyword">method</span>: <span class="string">"get"</span>,
    url: <span class="string">"demo.php"</span>,
    onSuccess: function(responseText) {
        $(<span class="string">"box"</span>).<span class="type">set</span>(<span class="string">"text"</span>, responseText);
    }
});
myRequest.send();
</code></pre><p>这样从服务器获取demo.php返回的文本信息并写入到id是box的元素内，关键是不用对页面进行刷新。</p>
<h2 id="进阶javascript"><strong>进阶javascript</strong></h2>
<p>原生javascript虽然能实现很多的功能，但只是初级的写法难以完成更复杂庞大的web开发。javascript的进阶的时候需要考虑的就是编写可维护易复用的javascript。就Object而言,像下面这样：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(first, last)</span> </span>{
    <span class="keyword">this</span>.first = first;
    <span class="keyword">this</span>.last = last;
}

Person.prototype.fullName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="keyword">this</span>.first + <span class="string">' '</span> + <span class="keyword">this</span>.last;
}

Person.prototype.toString = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">return</span> <span class="string">'[Person: '</span> + <span class="keyword">this</span>.fullName() + <span class="string">']'</span>;
};

<span class="keyword">var</span> simon = <span class="keyword">new</span> Person(<span class="string">'Simon'</span>, <span class="string">'Willison'</span>);

<span class="built_in">document</span>.write(simon.fullName());
</code></pre><p>ECMAScript为object类型定义了一个内部属性prototype。在对象的属性解析过程中，会需要用到<strong><em>这个内部属性所引用的对象链</em></strong>，即<strong><em>原型链</em></strong>，原型链终止于链中原型为null的对象。</p>
<p>这种组合继承的运用,有利于模块化和独立复用。其实也就涉及到设计模式的问题，设计模式是针对程序设计语言中的各类问题的解决方案，对于jQuery这类javascript库的源码，至少需要先明白设计模式。</p>
<h2 id="总结"><strong>总结</strong></h2>
<p>以上是目前我对javascript的理解。有关javascript的其他技术细节，还需要继续学习。。就到这里</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>javascript初学完一轮，这里需要把能想起来的东西整理一遍。当然javascript涉及的内容巨量，我只能以初学者的视角，描述出知识点的轮廓，但重要的细节也会尽力说明。<br>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://deacyn.com/tags/javascript/"/>
    
      <category term="note" scheme="http://deacyn.com/tags/note/"/>
    
      <category term="前端笔记" scheme="http://deacyn.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[新博客开通]]></title>
    <link href="http://deacyn.com/2015/02/08/%E6%96%B0%E5%8D%9A%E5%AE%A2%E5%BC%80%E9%80%9A/"/>
    <id>http://deacyn.com/2015/02/08/新博客开通/</id>
    <published>2015-02-08T12:25:08.000Z</published>
    <updated>2015-02-11T16:57:33.000Z</updated>
    <content type="html"><![CDATA[<p>到写下这段文字时，本博客也宣布初步完工。<br><a id="more"></a></p>
<h3 id="为什么弄独立博客？"><strong>为什么弄独立博客？</strong></h3>
<p>以前在lofter，点点，甚至qq空间里都写过东西，大部分是记录的问题解决方案，或者突发奇想的灵感。但是，总还会出现一些问题，比如：</p>
<p>1.有各种广告乱入。</p>
<p>2.不够酷炫。域名是别人的，只是在别人的菜园里种菜。</p>
<p>3.不够自由，需要审核，存在过滤。</p>
<p>所以本着回馈精神（这是自黑）。就像开源软件，我们不断地从开源社区获得那么多的便利与知识，当然也要回馈社区。</p>
<h3 id="关于"><strong>关于</strong></h3>
<p>这里的名字想来想去用了自己的英文名，当初稀里糊涂起名Deacyn，据说有信使的意思（后来没找到依据）。首页给出了我的联系方式，你可以在Github、Twitter和微博上找到我，也可以邮件联系。</p>
<p>就像“关于”介绍的那样，我希望在这里发布有关前端学习的文章和自己的一些漫画，可能还有看球的感悟。你也许还看到了“项目”，这是希望将来可以加入的内容。我还在思考具体内容，所以说本博客只是初步完工。</p>
<p>“爱好漫画与足球并学习web前端”，基于这样的描述，我做了这样的博客。希望这里的内容，无论是对作为球迷或漫迷的你，又或者前端同行的你，都能带来一些有用的信息，或者是一点点生活乐趣。</p>
<h3 id="说明"><strong>说明</strong></h3>
<p>本博客通过 <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>搭建，花了三天时间捣鼓和修改了样式，域名和主机利用了<a href="https://www.godaddy.com/" target="_blank" rel="external">Godaddy</a> 和<a href="http://www.dnspod.cn/" target="_blank" rel="external">DNSpod</a>如果你也对此有兴趣，可以自己搜索相关的介绍信息及教程。</p>
<p>撒花庆祝一下！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>到写下这段文字时，本博客也宣布初步完工。<br>]]>
    
    </summary>
    
      <category term="记录" scheme="http://deacyn.com/categories/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello post]]></title>
    <link href="http://deacyn.com/2015/02/07/Hello-post/"/>
    <id>http://deacyn.com/2015/02/07/Hello-post/</id>
    <published>2015-02-07T03:58:51.000Z</published>
    <updated>2015-02-08T06:33:50.000Z</updated>
    <content type="html"><![CDATA[]]></content>
    <summary type="html">
    <![CDATA[]]>
    </summary>
    
      <category term="test" scheme="http://deacyn.com/categories/test/"/>
    
  </entry>
  
</feed>
